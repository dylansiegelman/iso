<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Isometric Drawing App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      display: block;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <script>
// ===== STATE VARIABLES =====
let lines = [];
let fills;
let undoStack = [];

// Camera/View
let panX = 0, panY = 0;
let zoom = 1;
let minZoom = 0.19, maxZoom = 5;

// Grid settings - angled isometric (30Â°/150Â° lines)
let gridSpacing = 80;
let baseGridSpacing = 80;
let gridMult = 1;

// Tools
let currentTool = 'DRAW';
let currentHue = 200;
let hueSlider;

// Drawing state
let drawStart = null;
let isEditingVertex = false;
let holdTimer = null;
let isFingerDown = false; // Reliable touch tracking for iPad

// Panning state
let isPanning = false;
let panStartMouse = {x: 0, y: 0};
let panStartOffset = {x: 0, y: 0};

// Touch/pinch state
let lastTouchDist = 0;
let isPinching = false;

function setup() {
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight);
  fills = createGraphics(2000, 2000);
  fills.pixelDensity(1);
  fills.colorMode(HSB, 360, 100, 100);
  fills.clear();
  createUI();
  
  // Prevent browser pinch-zoom on the canvas
  let canvas = document.querySelector('canvas');
  
  canvas.addEventListener('gesturestart', function(e) {
    e.preventDefault();
  });
  
  canvas.addEventListener('gesturechange', function(e) {
    e.preventDefault();
  });
  
  canvas.addEventListener('gestureend', function(e) {
    e.preventDefault();
  });
}

function draw() {
  background(220);
  
  // Handle pinch-to-zoom for touch devices
  if (touches.length === 2) {
    let dx = touches[0].x - touches[1].x;
    let dy = touches[0].y - touches[1].y;
    let currentDist = Math.sqrt(dx * dx + dy * dy);
    
    if (isPinching) {
      let centerX = (touches[0].x + touches[1].x) / 2;
      let centerY = (touches[0].y + touches[1].y) / 2;
      
      if (centerX > 60) {
        let worldBefore = screenToWorld(centerX, centerY);
        let zoomChange = currentDist / lastTouchDist;
        zoom = constrain(zoom * zoomChange, minZoom, maxZoom);
        let worldAfter = screenToWorld(centerX, centerY);
        panX += (worldAfter.x - worldBefore.x) * zoom;
        panY += (worldAfter.y - worldBefore.y) * zoom;
      }
    } else {
      isPinching = true;
    }
    lastTouchDist = currentDist;
  } else {
    isPinching = false;
  }
  
  push();
  translate(panX, panY);
  scale(zoom);
  let offset = fills.width / 2;
  image(fills, -offset, -offset);
  drawIsometricGrid();
  stroke(0);
  strokeWeight(2 / zoom);
  for (let ln of lines) {
    line(ln.x1, ln.y1, ln.x2, ln.y2);
  }
  if (drawStart && currentTool === 'DRAW' && (mouseIsPressed || isFingerDown)) {
    let worldMouse = screenToWorld(mouseX, mouseY);
    let snapped = snapToGrid(worldMouse.x, worldMouse.y);
    stroke(0);
    strokeWeight(2 / zoom);
    line(drawStart.x, drawStart.y, snapped.x, snapped.y);
    if (isEditingVertex) {
      fill(255, 0, 0);
      noStroke();
      ellipse(snapped.x, snapped.y, 8 / zoom);
    }
  }
  pop();
  hueSlider.style('background', `hsl(${hueSlider.value()}, 70%, 50%)`);
  updateButtonStyles();
}

function drawIsometricGrid() {
  if (zoom < 0.1) return;
  stroke(100);
  strokeWeight(0.5 / zoom);
  noFill();
  let topLeft = screenToWorld(0, 0);
  let bottomRight = screenToWorld(width, height);
  let margin = gridSpacing * 5;
  let minX = topLeft.x - margin;
  let maxX = bottomRight.x + margin;
  let minY = topLeft.y - margin;
  let maxY = bottomRight.y + margin;
  let tan30 = 1 / Math.sqrt(3);
  let verticalSpacing = gridSpacing * 2 / Math.sqrt(3);
  let startCol = floor(minX / gridSpacing);
  let endCol = ceil(maxX / gridSpacing);
  for (let col = startCol; col <= endCol; col++) {
    let x = col * gridSpacing;
    line(x, minY, x, maxY);
  }
  let startOffset1 = floor((minY - tan30 * maxX) / verticalSpacing);
  let endOffset1 = ceil((maxY - tan30 * minX) / verticalSpacing);
  for (let i = startOffset1; i <= endOffset1; i++) {
    let c = i * verticalSpacing;
    line(minX, tan30 * minX + c, maxX, tan30 * maxX + c);
  }
  let startOffset2 = floor((minY + tan30 * minX) / verticalSpacing);
  let endOffset2 = ceil((maxY + tan30 * maxX) / verticalSpacing);
  for (let i = startOffset2; i <= endOffset2; i++) {
    let c = i * verticalSpacing;
    line(minX, -tan30 * minX + c, maxX, -tan30 * maxX + c);
  }
}

function screenToWorld(sx, sy) {
  return {x: (sx - panX) / zoom, y: (sy - panY) / zoom};
}

function worldToBuffer(wx, wy) {
  let offset = fills.width / 2;
  return {x: floor(wx + offset), y: floor(wy + offset)};
}

function snapToGrid(worldX, worldY) {
  let cos30 = cos(PI / 6);
  let sin30 = sin(PI / 6);
  let spacing = gridSpacing;
  let u = worldX / spacing;
  let v = (worldY - worldX * sin30 / cos30) / (spacing * sin30 / cos30);
  u = Math.round(u);
  v = Math.round(v);
  let snapX = u * spacing;
  let snapY = v * spacing * sin30 / cos30 + snapX * sin30 / cos30;
  return {x: snapX, y: snapY};
}

function mousePressed() {
  isFingerDown = true;
  if (mouseX < 60) return;
  if (mouseButton === CENTER || keyIsDown(32)) {
    isPanning = true;
    panStartMouse = {x: mouseX, y: mouseY};
    panStartOffset = {x: panX, y: panY};
    return;
  }
  let worldMouse = screenToWorld(mouseX, mouseY);
  if (currentTool === 'PICK') {
    let bufCoords = worldToBuffer(worldMouse.x, worldMouse.y);
    let c = fills.get(bufCoords.x, bufCoords.y);
    if (alpha(c) > 0) {
      currentHue = hue(c);
      hueSlider.value(currentHue);
      currentTool = 'FILL';
    }
  }
  else if (currentTool === 'DRAW') {
    isEditingVertex = false;
    let clickWorld = {x: worldMouse.x, y: worldMouse.y};
    let nearestDist = 10 / zoom;
    let nearVertex = false;
    for (let i = 0; i < lines.length; i++) {
      let ln = lines[i];
      let d1 = dist(clickWorld.x, clickWorld.y, ln.x1, ln.y1);
      let d2 = dist(clickWorld.x, clickWorld.y, ln.x2, ln.y2);
      if (d1 < nearestDist || d2 < nearestDist) {
        nearVertex = true;
        break;
      }
    }
    if (nearVertex) {
      let holdStartX = mouseX;
      let holdStartY = mouseY;
      holdTimer = setTimeout(() => {
        if (isFingerDown && dist(mouseX, mouseY, holdStartX, holdStartY) < 10) {
          let bestDist = 10 / zoom;
          let nearestLine = -1;
          let useEnd1 = false;
          for (let i = 0; i < lines.length; i++) {
            let ln = lines[i];
            let d1 = dist(clickWorld.x, clickWorld.y, ln.x1, ln.y1);
            let d2 = dist(clickWorld.x, clickWorld.y, ln.x2, ln.y2);
            if (d1 < bestDist) {
              bestDist = d1;
              nearestLine = i;
              useEnd1 = true;
            } else if (d2 < bestDist) {
              bestDist = d2;
              nearestLine = i;
              useEnd1 = false;
            }
          }
          if (nearestLine >= 0) {
            saveUndo();
            isEditingVertex = true;
            let ln = lines[nearestLine];
            drawStart = useEnd1 ? {x: ln.x2, y: ln.y2} : {x: ln.x1, y: ln.y1};
            lines.splice(nearestLine, 1);
          }
        }
      }, 1000);
    }
    let snapped = snapToGrid(worldMouse.x, worldMouse.y);
    drawStart = snapped;
  }
  else if (currentTool === 'FILL') {
    saveUndo();
    // Create color in HSB without corrupting main canvas state
    let h = currentHue;
    let fillR = red(color(`hsl(${h}, 70%, 80%)`));
    let fillG = green(color(`hsl(${h}, 70%, 80%)`));
    let fillB = blue(color(`hsl(${h}, 70%, 80%)`));
    let fillColor = color(fillR, fillG, fillB);
    let bufCoords = worldToBuffer(worldMouse.x, worldMouse.y);
    floodFill(bufCoords.x, bufCoords.y, fillColor);
    drawStart = null; // Reset draw state after fill
  }
  else if (currentTool === 'ERASE') {
    saveUndo();
    let threshold = 15 / zoom;
    lines = lines.filter(ln => distToSegment(worldMouse.x, worldMouse.y, ln.x1, ln.y1, ln.x2, ln.y2) > threshold);
  }
}

function mouseDragged() {
  if (isPanning) {
    panX = panStartOffset.x + (mouseX - panStartMouse.x);
    panY = panStartOffset.y + (mouseY - panStartMouse.y);
  }
}

function mouseReleased() {
  isFingerDown = false;
  isPanning = false;
  if (holdTimer) {
    clearTimeout(holdTimer);
    holdTimer = null;
  }
  if (currentTool === 'DRAW' && drawStart) {
    let worldMouse = screenToWorld(mouseX, mouseY);
    let snapped = snapToGrid(worldMouse.x, worldMouse.y);
    if (dist(drawStart.x, drawStart.y, snapped.x, snapped.y) > 5) {
      if (!isEditingVertex) saveUndo();
      lines.push({x1: drawStart.x, y1: drawStart.y, x2: snapped.x, y2: snapped.y});
    }
  }
  drawStart = null;
  isEditingVertex = false;
}

function doubleClicked() {
  if (currentTool === 'ERASE' && mouseX > 60) {
    saveUndo();
    let worldMouse = screenToWorld(mouseX, mouseY);
    let bufCoords = worldToBuffer(worldMouse.x, worldMouse.y);
    floodFill(bufCoords.x, bufCoords.y, color(0, 0, 0, 0), true);
  }
}

function mouseWheel(event) {
  if (mouseX < 60) return;
  
  // Prevent default browser zoom
  event.preventDefault();
  
  let worldBefore = screenToWorld(mouseX, mouseY);
  let zoomFactor = 1 - event.delta * 0.001;
  zoom = constrain(zoom * zoomFactor, minZoom, maxZoom);
  let worldAfter = screenToWorld(mouseX, mouseY);
  panX += (worldAfter.x - worldBefore.x) * zoom;
  panY += (worldAfter.y - worldBefore.y) * zoom;
  return false;
}

function keyPressed() {
  if (key === '+' || key === '=') zoom = constrain(zoom * 1.2, minZoom, maxZoom);
  else if (key === '-' || key === '_') zoom = constrain(zoom / 1.2, minZoom, maxZoom);
  else if (key === '0') { panX = 0; panY = 0; zoom = 1; }
}

function floodFill(startX, startY, fillColor, isErasing = false) {
  let bufferWidth = fills.width;
  let bufferHeight = fills.height;
  if (startX < 0 || startX >= bufferWidth || startY < 0 || startY >= bufferHeight) return;
  let mask = createGraphics(bufferWidth, bufferHeight);
  mask.pixelDensity(1);
  mask.background(255);
  mask.stroke(0);
  mask.strokeWeight(2.5);
  mask.strokeCap(ROUND);
  mask.strokeJoin(ROUND);
  let offset = bufferWidth / 2;
  mask.push();
  mask.translate(offset, offset);
  for (let ln of lines) mask.line(ln.x1, ln.y1, ln.x2, ln.y2);
  mask.pop();
  mask.loadPixels();
  let maskStartIdx = (startY * bufferWidth + startX) * 4;
  if (mask.pixels[maskStartIdx] < 128) {
    mask.remove();
    return;
  }
  let stack = [[startX, startY]];
  let visited = new Uint8Array(bufferWidth * bufferHeight);
  let maxIterations = 300000;
  let iterations = 0;
  while (stack.length > 0 && iterations < maxIterations) {
    iterations++;
    let [x, y] = stack.pop();
    if (x < 0 || x >= bufferWidth || y < 0 || y >= bufferHeight) continue;
    let key = y * bufferWidth + x;
    if (visited[key]) continue;
    let maskIdx = key * 4;
    if (mask.pixels[maskIdx] < 128) continue;
    visited[key] = 1;
    if (isErasing) fills.set(x, y, color(0, 0, 0, 0));
    else fills.set(x, y, fillColor);
    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
  }
  fills.updatePixels();
  mask.remove();
}

function saveUndo() {
  undoStack.push({
    lines: lines.map(l => ({...l})),
    fills: fills.get(),
    panX: panX,
    panY: panY,
    zoom: zoom
  });
  if (undoStack.length > 25) undoStack.shift();
}

function undo() {
  if (undoStack.length > 0) {
    let state = undoStack.pop();
    lines = state.lines;
    fills.clear();
    fills.image(state.fills, 0, 0);
    panX = state.panX;
    panY = state.panY;
    zoom = state.zoom;
  }
}

function createUI() {
  createDiv('').position(0, 0).size(60, height).style('background', '#ddd').style('border-right', '2px solid #999');
  let yPos = height * 0.15 - 36;
  hueSlider = createSlider(0, 360, 200)
    .position(-45, yPos + 45)
    .size(140)
    .style('transform', 'rotate(90deg)')
    .style('appearance', 'none')
    .style('height', '10px')
    .style('border-radius', '5px');
  hueSlider.input(() => currentHue = hueSlider.value());
  yPos += 140;
  let tools = [
    {icon: 'âœï¸', mode: 'DRAW'},
    {icon: 'ðŸª£', mode: 'FILL'},
    {icon: 'ðŸŽ¨', mode: 'PICK'},
    {icon: 'ðŸ§½', mode: 'ERASE'}
  ];
  for (let tool of tools) {
    let btn = createButton(tool.icon).position(12, yPos).size(36, 36).mousePressed(() => currentTool = tool.mode);
    btn.attribute('data-mode', tool.mode);
    yPos += 40;
  }
  yPos += 10;
  createButton('â†©ï¸').position(12, yPos).size(36, 36).mousePressed(undo);
  yPos += 40;
  createButton('ðŸŒ').position(12, yPos).size(36, 36).mousePressed(() => {
    saveUndo();
    gridMult = gridMult === 1 ? 0.5 : (gridMult === 0.5 ? 0.25 : (gridMult === 0.25 ? 0.125 : 1));
    gridSpacing = baseGridSpacing * gridMult;
  });
  yPos += 40;
  createButton('âŒ‚').position(12, yPos).size(36, 36).mousePressed(() => {
    panX = 0;
    panY = 0;
    zoom = 1;
  });
  yPos += 40;
  createButton('ðŸ—‘ï¸').position(12, yPos).size(36, 36).mousePressed(() => {
    saveUndo();
    lines = [];
    fills.clear();
  });
  yPos += 40;
  createButton('ðŸ’¾').position(12, yPos).size(36, 36).mousePressed(savePNG);
}

function savePNG() {
  let exportWidth = 2732;
  let exportHeight = 2048;
  let exportGraphics = createGraphics(exportWidth, exportHeight);
  exportGraphics.pixelDensity(1);
  exportGraphics.background(220);
  let viewportWidth = width - 60;
  let viewportHeight = height;
  let scaleX = exportWidth / viewportWidth;
  let scaleY = exportHeight / viewportHeight;
  exportGraphics.push();
  exportGraphics.translate(panX * scaleX, panY * scaleY);
  exportGraphics.scale(zoom * scaleX, zoom * scaleY);
  let offset = fills.width / 2;
  exportGraphics.image(fills, -offset, -offset);
  exportGraphics.stroke(0);
  exportGraphics.strokeWeight(2 / zoom);
  for (let ln of lines) {
    exportGraphics.line(ln.x1, ln.y1, ln.x2, ln.y2);
  }
  exportGraphics.pop();
  save(exportGraphics, 'isometric_drawing.png');
  exportGraphics.remove();
}

function updateButtonStyles() {
  selectAll('button').forEach(btn => {
    if (btn.attribute('data-mode') === currentTool) {
      btn.style('background-color', '#8B4FBF');
      btn.style('color', 'white');
    } else {
      btn.style('background-color', '#fff');
      btn.style('color', 'black');
    }
  });
}

function distToSegment(px, py, x1, y1, x2, y2) {
  let l2 = dist(x1, y1, x2, y2) ** 2;
  if (l2 === 0) return dist(px, py, x1, y1);
  let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
  t = constrain(t, 0, 1);
  return dist(px, py, x1 + t * (x2 - x1), y1 + t * (y2 - y1));
}
  </script>
</body>
</html>
